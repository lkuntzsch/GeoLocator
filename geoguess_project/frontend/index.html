<!DOCTYPE html>
<html>
<head>
  <title>Bildbasierte Geolokalisierung</title>
  <meta charset="UTF-8">

  <link rel="stylesheet" href="style.css">

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>

<body>
  <header class="header-box">
      <div class="header-content">
        <img src="data/geoguessLogo.png" alt="Logo" class="logo" onclick="location.reload()" style="cursor: pointer;">
        <h1 onclick="location.reload()" style="cursor: pointer;">
          <span class="spoti">Spoti</span><span class="find">Find</span>
        </h1>
      </div>
  </header>

  <div class="background-box" id="beforeDividerBox">
    <label id="uploadArea" for="fileInput">
      <div class="upload-icon">
        <img src="data/upload.png" alt="Upload Icon" />
      </div>
      <span class="upload-text">Bild hierher ziehen oder Feld anklicken</span>
    </label>
    <input type="file" id="fileInput" accept="image/*" />

    <img id="uploadedImage" alt="Hochgeladenes Bild wird hier angezeigt" />

    <label id="uploadAreaSmall" for="fileInputSmall">
      <div class="upload-icon">
        <img src="data/upload.png" alt="Upload Icon" />
      </div>
      <span class="upload-text">Neues Bild hierher ziehen oder klicken</span>
    </label>
    <input type="file" id="fileInputSmall" accept="image/*" />

    <div id="divider" class="divider"></div>

    <div id="visuals">
      <div class="chartContainer">
        <canvas id="barChart"></canvas>
      </div>
      <div id="map">
        <div id="mapOceanOverlay"></div>
      </div>
    </div>

    <div id="divider2" class="divider"></div>
    <div id="chatBox">
      <p id="chatText"></p>
    </div>
    <div id="wikiBox" style="display: none;">
      <img id="wikiImage" alt="" style="max-width: 300px; display: block; margin: 1rem auto;" />
      <p id="wikiDescription"></p>
      <a id="wikiLink" href="" target="_blank" rel="noopener noreferrer" style="color: white;">Mehr auf Wikipedia</a>
    </div>
    

    <h2 id="newTitle" style="display: none; visibility: hidden;"></h2>
    <pre id="result" style="display: none; visibility: hidden;"></pre>

  </div>

  <script>
    // Scrolling Animation script
    function smoothScrollTo(element, extraOffset = 0) {
      const targetY = element.getBoundingClientRect().top + window.pageYOffset - window.innerHeight / 2 + element.offsetHeight / 2 + extraOffset;
      const startY = window.pageYOffset;
      const distance = targetY - startY;
      const duration = 1000;
      let startTime = null;

      function step(currentTime) {
        if (!startTime) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const progress = Math.min(timeElapsed / duration, 1);

        window.scrollTo(0, startY + distance * easeInOutQuad(progress));

        if (timeElapsed < duration) {
          requestAnimationFrame(step);
        }
      }

      function easeInOutQuad(t) {
        return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      }

      requestAnimationFrame(step);
    }

    const map = L.map('map').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    function drawChart(data) {
      const ctx = document.getElementById('barChart').getContext('2d');
      if (window.myChart) window.myChart.destroy();

      // 1. Datenpaare [Label, Wert] bilden
      const entries = Object.entries(data)
        .map(([label, prob]) => [label, prob * 100]);

      // 2. Absteigend nach Wert sortieren
      entries.sort((a, b) => b[1] - a[1]);

      // 3. Neue Arrays für Chart.js
      const labels = entries.map(e => e[0]);
      const values = entries.map(e => e[1]);

      const sortedIndices = values
        .map((val, idx) => ({ val, idx }))
        .sort((a, b) => b.val - a.val)
        .map(e => e.idx);

      const top3Indices = sortedIndices.slice(0, 3);
      const barColors = values.map((_, idx) =>
        top3Indices.includes(idx) ? '#c8f9db' : '#94b9ff'
      );

      // Darkmode fest angenommen (darkmode = true)
      const darkmode = true;

      window.myChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Wahrscheinlichkeit (%)',
            data: values,
            backgroundColor: barColors
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: '#eeeeee'
              },
              grid: {
                color: '#444444'
              }
            },
            x: {
              ticks: {
                color: '#eeeeee'
              },
              grid: {
                color: '#444444'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#eeeeee'
              }
            }
          }
        }
      });
      window.lastChartData = data;
    }

    function showTopCountries(countries) {
      map.eachLayer(layer => {
        if (layer instanceof L.Circle) {
          map.removeLayer(layer);
        }
      });

      const top1 = countries[0];

      const wikiBox = document.getElementById('wikiBox');
      const wikiImg = document.getElementById('wikiImage');
      const wikiDesc = document.getElementById('wikiDescription');
      const wikiLink = document.getElementById('wikiLink');

      if (top1 && top1.wiki) {
        wikiImg.src = top1.wiki.thumbnail || "";
        wikiImg.alt = `Bild von ${top1.name || "Land"}`;
        wikiDesc.textContent = "";
        wikiLink.href = top1.wiki.source || "#";
      
        wikiBox.style.display = 'block';
      } else {
        wikiBox.style.display = 'none';
      }
      


      countries.forEach(({ name, lat, lon, probability }, index) => {
        const isTop3 = index < 3;

        const circle = L.circle([lat, lon], {
          color: isTop3 ? '#c8f9db' : '#94b9ff',
          fillColor: isTop3 ? '#c8f9db' : '#94b9ff',
          fillOpacity: probability,
          radius: 500000
        }).addTo(map);

        circle.bindPopup(`${name}: ${(probability * 100).toFixed(1)}%`);
      });

      if (countries.length > 0) {
        // Zoom auf das Top-1-Land
        const top = countries[0];
        map.setView([top.lat, top.lon], 3);
      } else {
        map.setView([20, 0], 2);
      }

      map.invalidateSize();
    }

    // Typewriter animation
    function typeWriterEffect(text, elementId, speed = 100) {
      const element = document.getElementById(elementId);
      let i = 0;
      element.innerHTML = "";

      function type() {
        if (i < text.length) {
          element.innerHTML += text.charAt(i);
          i++;
          setTimeout(type, speed);
        }
      }

      type();
    }

    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const uploadedImage = document.getElementById('uploadedImage');
    const uploadAreaSmall = document.getElementById('uploadAreaSmall');
    const fileInputSmall = document.getElementById('fileInputSmall');
    const divider = document.getElementById('divider');
    const divider2 = document.getElementById('divider2');
    const visuals = document.getElementById('visuals');
    const chatBox = document.getElementById('chatBox');
    const resultPre = document.getElementById('result');

    let textTyped = false;
    let firstUploadDone = false;
    let storedExplanationText = "";

    async function processFile(file) {
      if (!file) return;

      // Fade out
      if (visuals.style.display === 'flex') {
        visuals.style.transitionDuration = '400ms';
        visuals.style.opacity = 0;
        await new Promise(r => setTimeout(r, 400));
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedImage.src = e.target.result;
        uploadedImage.style.display = 'block';

        document.getElementById('beforeDividerBox').style.paddingTop = "150px";
      };
      reader.readAsDataURL(file);

      const formData = new FormData();
      formData.append('image', file);

      try {
        const response = await fetch('http://localhost:5001/upload', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          resultPre.style.display = 'none';
          resultPre.textContent = 'Fehler beim Hochladen: ' + response.status;
          return;
        }

        const data = await response.json();
        const explanationText = data.explanation;
        resultPre.style.display = 'none';
        resultPre.textContent = JSON.stringify(data, null, 2);

        drawChart(data.probabilities);
        showTopCountries(data.topCountries);

        uploadArea.style.display = 'none';
        uploadAreaSmall.style.display = 'flex';
        divider.style.display = 'block';
        divider2.style.display = 'none';
        visuals.style.display = 'flex';
        visuals.style.transitionDuration = '1000ms';
        document.getElementById('newTitle').style.display = 'none';
        chatBox.style.display = 'block';
        textTyped = false;
        chatBox.classList.remove('visible');
        document.getElementById("chatText").innerHTML = "";
        const explanation = data.explanation || "";
        const top1 = data.topCountries[0];
        const wikiText = top1?.wiki?.description || "";
        
        storedExplanationText = explanation + "\n\n" + wikiText;
        
                firstUploadDone = true;
        map.invalidateSize();

        // Fade in
        setTimeout(() => {
          visuals.style.opacity = 1;
        }, 400); // wait before fade in. time in ms

        map.invalidateSize();

        smoothScrollTo(visuals, 90);

      } catch (error) {
        resultPre.style.display = 'none';
        resultPre.textContent = 'Netzwerkfehler: ' + error.message;
      }
    }

    fileInput.addEventListener('change', () => {
      processFile(fileInput.files[0]);
    });

    fileInputSmall.addEventListener('change', () => {
      processFile(fileInputSmall.files[0]);
    });

    function setupDragDrop(uploadLabel, fileInputElement) {
      uploadLabel.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadLabel.classList.add('dragover');
      });

      uploadLabel.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadLabel.classList.remove('dragover');
      });

      uploadLabel.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadLabel.classList.remove('dragover');
        if (e.dataTransfer.files.length > 0) {
          processFile(e.dataTransfer.files[0]);
          fileInputElement.value = '';
        }
      });
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && firstUploadDone && !textTyped) {
          chatBox.classList.add('visible');
          typeWriterEffect(storedExplanationText, "chatText", 10);
          textTyped = true;
        }
      });
    }, {
      threshold: 0.5
    });

    observer.observe(chatBox);

    setupDragDrop(uploadArea, fileInput);
    setupDragDrop(uploadAreaSmall, fileInputSmall);
  </script>

</body>
</html>
