<!DOCTYPE html>
<html>
<head>
  <title>Bildbasierte Geolokalisierung</title>
  <meta charset="UTF-8">

  <link rel="stylesheet" href="style.css">

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>

<body>
  <header class="header-box">
      <div class="header-content">
        <img src="data/geoguessLogo.png" alt="Logo" class="logo" onclick="location.reload()" style="cursor: pointer;">
        <h1 onclick="location.reload()" style="cursor: pointer;">
          <span class="spoti">Spoti</span><span class="find">Find</span>
        </h1>
      </div>
  </header>

  <div class="background-box" id="beforeDividerBox">
    <div id="intro">
      <h2>
        <span class="spoti">Spoti</span><span class="find">Find</span> – ML basierte Standortermittlung
      </h2>
      <p>Willkommen! Lass uns das Land auf deinem Foto herausfinden!</p>
      
    </div>
    <label id="uploadArea" for="fileInput">
      <div class="upload-icon">
        <img src="data/upload.png" alt="Upload Icon" />
      </div>
      <span class="upload-text">Bild hierher ziehen oder Feld anklicken</span>
    </label>
    <input type="file" id="fileInput" accept="image/*" />

    <img id="uploadedImage" alt="Hochgeladenes Bild wird hier angezeigt" />

    <label id="uploadAreaSmall" for="fileInputSmall">
      <div class="upload-icon">
        <img src="data/upload.png" alt="Upload Icon" />
      </div>
      <span class="upload-text">Neues Bild hierher ziehen oder klicken</span>
    </label>
    <input type="file" id="fileInputSmall" accept="image/*" />

    <div id="divider" class="divider"></div>

    <div id="visuals">
      <div class="chartContainer">
        <canvas id="barChart"></canvas>
      </div>
      <div id="map">
        <div id="mapOceanOverlay"></div>
      </div>
    </div>

    <div id="divider2" class="divider"></div>
    <div id="infoContainer">
      <!-- 1. Box: Wiki (Flagge) -->
      <div id="wikiBox" style="display: none;">
        <img id="wikiImage" alt="" />
        <p id="wikiDescription"></p>
        <a id="wikiLink" href="" target="_blank" rel="noopener noreferrer">Mehr auf Wikipedia</a>
      </div>
      <!-- 2. Box: Chat (Text) -->
      <div id="chatBox">
        <p id="chatText"></p>
      </div>
    </div>

    <h2 id="newTitle" style="display: none; visibility: hidden;"></h2>
    <pre id="result" style="display: none; visibility: hidden;"></pre>

  </div>

  <script>
    // Scrolling Animation script
    function smoothScrollTo(element, extraOffset = 0) {
      const targetY = element.getBoundingClientRect().top + window.pageYOffset - window.innerHeight / 2 + element.offsetHeight / 2 + extraOffset;
      const startY = window.pageYOffset;
      const distance = targetY - startY;
      const duration = 1000;
      let startTime = null;

      function step(currentTime) {
        if (!startTime) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const progress = Math.min(timeElapsed / duration, 1);

        window.scrollTo(0, startY + distance * easeInOutQuad(progress));

        if (timeElapsed < duration) {
          requestAnimationFrame(step);
        }
      }

      function easeInOutQuad(t) {
        return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      }

      requestAnimationFrame(step);
    }

    const map = L.map('map', {
      minZoom: 3,  // Mindestzoom auf den Kontinent
      maxZoom: 6   // Maximalzoom, damit man nicht zu weit in ein Land hineinzoomt
    }).setView([54.5260, 15.2551], 3); // Zentrierung auf Europa
      // Zentrierung auf Europa mit Zoom-Level 3
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    function drawChart(data) {
      const ctx = document.getElementById('barChart').getContext('2d');
      if (window.myChart) window.myChart.destroy();
    
      const entries = Object.entries(data)
        .map(([label, prob]) => [label, prob * 100]);
    
      entries.sort((a, b) => b[1] - a[1]);
    
      const labels = entries.map(e => e[0]);
      const values = entries.map(e => e[1]);
    
      // Top-5 Indices bestimmen
      const top5Indices = values
        .map((val, idx) => ({ val, idx }))
        .sort((a, b) => b.val - a.val)
        .map(e => e.idx);
    
      const barColors = values.map((_, idx) => {
        if (top5Indices[0] === idx) {
          return '#c8f9db';  // Top 1 in Rot
        } else if (top5Indices.slice(1, 5).includes(idx)) {
          return '#94b9ff';  // Top 2 bis 5 in Grün
        }
        return '#94b9ff'; // Restliche Länder in Blau
      });
    
      window.myChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Wahrscheinlichkeit (%)',
            data: values,
            backgroundColor: barColors
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: '#eeeeee'
              },
              grid: {
                color: '#444444'
              }
            },
            x: {
              ticks: {
                color: '#eeeeee'
              },
              grid: {
                color: '#444444'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#eeeeee'
              }
            }
          }
        }
      });
      window.lastChartData = data;
    }
    const isoToCountryName = {
      "DE": "Germany",
      "GB": "United Kingdom",
      "FR": "France",
      "SE": "Sweden",
      "PL": "Poland",
      "IT": "Italy",
      "ES": "Spain",
      "RO": "Romania",
      "PT": "Portugal",
      "NL": "Netherlands",
      "FI": "Finland",
      "DK": "Denmark",
      "GR": "Greece",
      "HU": "Hungary",
      "AT": "Austria",
      "IE": "Ireland",
      "NO": "Norway",
      "EE": "Estonia",
      "LV": "Latvia",
      "BE": "Belgium",
      "HR": "Croatia",
      "CZ": "Czech Republic",
      "RS": "Serbia",
      "CH": "Switzerland",
      "SK": "Slovakia",
      "BG": "Bulgaria",
      "LT": "Lithuania",
      "SI": "Slovenia",
      "LU": "Luxembourg",
      "MT": "Malta"
    };
    
    function showTopCountries(countries) {
      // countries ist jetzt: [{code:"DE",lat:…,lon:…,probability:…,wiki:{…}}, …]
      // daraus bauen wir uns die ISO‑Codes und Namen:
      const countryCodes = countries.map(c => c.code);
      const countryNames = countryCodes.map(code => isoToCountryName[code]);
    
      // Wiki‑Box für Top‑1 direkt vor dem GeoJSON‑Layer setzen:
      const top1 = countries[0];
      const wikiBox = document.getElementById('wikiBox');
      const wikiImg = document.getElementById('wikiImage');
      const wikiDesc = document.getElementById('wikiDescription');
      const wikiLink = document.getElementById('wikiLink');
      if (top1?.wiki) {
        wikiImg.src         = top1.wiki.thumbnail || "";
        wikiDesc.textContent= "";
        wikiLink.href       = top1.wiki.source      || "#";
        wikiBox.style.display = 'block';
      } else {
        wikiBox.style.display = 'none';
      }
    
      // dann erst die GeoJSON‑Darstellung
      map.eachLayer(layer => {
        if (layer instanceof L.GeoJSON) map.removeLayer(layer);
      });
      fetch('http://localhost:5001/geojson')
        .then(res => res.json())
        .then(data => {
          const filtered = {
            type: "FeatureCollection",
            features: data.features.filter(f =>
              countryNames.includes(f.properties.name)
            )
          };
          L.geoJSON(filtered, {
            style(feature) {
              const nm = feature.properties.name;
              const idx = countryNames.indexOf(nm);
              if (idx === 0) return { color:'#c8f9db', weight:2, opacity:1 };
              if (idx > 0 && idx < 5) return { color:'#94b9ff', weight:2, opacity:1 };
              return { color:'#94b9ff', weight:1, opacity:0.7 };
            },
            onEachFeature(feature, layer) {
              layer.bindPopup(`<strong>${feature.properties.name}</strong>`);
            }
          }).addTo(map);
        })
        .catch(err => console.error(err));
    }
    
    
    
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const uploadedImage = document.getElementById('uploadedImage');
    const uploadAreaSmall = document.getElementById('uploadAreaSmall');
    const fileInputSmall = document.getElementById('fileInputSmall');
    const divider = document.getElementById('divider');
    const divider2 = document.getElementById('divider2');
    const visuals = document.getElementById('visuals');
    const chatBox = document.getElementById('chatBox');
    const resultPre = document.getElementById('result');

    let textTyped = false;
    let firstUploadDone = false;
    let storedExplanationText = "";

    async function processFile(file) {
      if (!file) return;
    
      // Fade out
      if (visuals.style.display === 'flex') {
        visuals.style.transitionDuration = '400ms';
        visuals.style.opacity = 0;
        await new Promise(r => setTimeout(r, 400));
      }
    
      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedImage.src = e.target.result;
        uploadedImage.style.display = 'block';
    
        document.getElementById('beforeDividerBox').style.paddingTop = "150px";
      };
      reader.readAsDataURL(file);
    
      const formData = new FormData();
      formData.append('image', file);
    
      try {
        const response = await fetch('http://localhost:5001/upload', {
          method: 'POST',
          body: formData
        });
    
        if (!response.ok) {
          resultPre.style.display = 'none';
          resultPre.textContent = 'Fehler beim Hochladen: ' + response.status;
          return;
        }
    
        const data = await response.json();
        const explanationText = data.explanation;
        resultPre.style.display = 'none';
        resultPre.textContent = JSON.stringify(data, null, 2);
    
        drawChart(data.probabilities);
        // neu
        showTopCountries(data.topCountries);
            
        uploadArea.style.display = 'none';
        uploadAreaSmall.style.display = 'flex';
        divider.style.display = 'block';
        divider2.style.display = 'none';
        visuals.style.display = 'flex';
        visuals.style.transitionDuration = '1000ms';
        document.getElementById('newTitle').style.display = 'none';
        chatBox.style.display = 'block';
        textTyped = false;
        chatBox.classList.remove('visible');
        document.getElementById("chatText").innerHTML = "";
        const explanation = data.explanation || "";
        const top1 = data.topCountries[0];
        const wikiText = top1?.wiki?.description || "";
        // Beispiel: Ausgabe der relevanten Daten
        console.log(top1);
        console.log(wikiText);
        
        storedExplanationText = explanation + "\n\n" + wikiText;
        
        firstUploadDone = true;
        map.invalidateSize();
    
        // Fade in
        setTimeout(() => {
          visuals.style.opacity = 1;
        }, 400); // wait before fade in. time in ms
    
        map.invalidateSize();
    
        smoothScrollTo(visuals, -60);
    
      } catch (error) {
        resultPre.style.display = 'none';
        resultPre.textContent = 'Netzwerkfehler: ' + error.message;
      }
    }    

    fileInput.addEventListener('change', () => {
      processFile(fileInput.files[0]);
    });

    fileInputSmall.addEventListener('change', () => {
      processFile(fileInputSmall.files[0]);
    });

    function setupDragDrop(uploadLabel, fileInputElement) {
      uploadLabel.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadLabel.classList.add('dragover');
      });

      uploadLabel.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadLabel.classList.remove('dragover');
      });

      uploadLabel.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadLabel.classList.remove('dragover');
        if (e.dataTransfer.files.length > 0) {
          processFile(e.dataTransfer.files[0]);
          fileInputElement.value = '';
        }
      });
    }

    function typeWriterEffect(text, elementId, speed) {
      let i = 0;
      const element = document.getElementById(elementId);
      
      function type() {
        if (i < text.length) {
          element.innerHTML += text.charAt(i);
          i++;
          setTimeout(type, speed);
        }
      }
      type();
    }
    

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && firstUploadDone && !textTyped) {
          chatBox.classList.add('visible');
          typeWriterEffect(storedExplanationText, "chatText", 5);
          textTyped = true;
        }
      });
    }, {
      threshold: 0.5
    });

    observer.observe(chatBox);

    setupDragDrop(uploadArea, fileInput);
    setupDragDrop(uploadAreaSmall, fileInputSmall);
  </script>

</body>
</html>
